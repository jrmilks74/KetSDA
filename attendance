# app.R
library(shiny)
library(tidyverse)
library(lubridate)
library(scales)
library(timetk)
library(plotly)
library(knitr)
library(kableExtra)
library(googlesheets4)

# Forecasting stack
library(modeltime)
library(parsnip)
library(workflows)
library(rsample)
library(yardstick)
library(imputeTS)
library(timeDate)

# Weighted ensembling
suppressWarnings({
        ok_ens <- requireNamespace("modeltime.ensemble", quietly = TRUE)
        if (ok_ens) library(modeltime.ensemble)
})

options(shiny.fullstacktrace = TRUE)

## --------------------------
## 1) Data load
## --------------------------
options(gargle_oauth_email = TRUE,
        gargle_oauth_cache = "KetSDA/.secrets/")
suppressMessages(gs4_auth(email = "office@ketsda.org"))

Weekly_data <- read_sheet(
        "https://docs.google.com/spreadsheets/d/1BsQR4TyAMkV2H09jzuj5yrOIotnOBTzLoSZ0r5PsBpk/edit#gid=0",
        col_names = TRUE,
        col_types = "Ddddddc"
) |>
        rename(
                Ascent      = "First/Ascent",
                Sanctuary   = "Second/Sanctuary",
                In_person   = "total.attendance"
        ) |>
        mutate(
                Week = isoweek(Date),
                Online           = rowSums(across(c(AscentOnline, SanctuaryOnline)), na.rm = TRUE),
                Total            = Online + In_person,
                Total_Ascent     = Ascent + coalesce(AscentOnline, 0),
                Total_Sanctuary  = Sanctuary + coalesce(SanctuaryOnline, 0)
        ) |>
        mutate(
                Online           = na_if(Online, 0),
                Total            = na_if(Total, 0),
                Total_Ascent     = na_if(Total_Ascent, 0),
                Total_Sanctuary  = na_if(Total_Sanctuary, 0)
        )

## ----------------------------------------
## 2) Column mapping
## ----------------------------------------
svc_map <- list(
        overall = list(in_person = "In_person", online = "Online", total = "Total"),
        ascent  = list(in_person = "Ascent",    online = "AscentOnline", total = "Total_Ascent"),
        sanct   = list(in_person = "Sanctuary", online = "SanctuaryOnline", total = "Total_Sanctuary")
)

## --------------------------
## 3) Helpers
## --------------------------
normalize_metric_names <- function(df) { names(df) <- gsub("^\\.", "", names(df)); df }

normalize_forecast_cols <- function(fc) {
        nm <- names(fc)
        if (!".index" %in% nm) {
                cand <- intersect(c(".date","date","index"), nm)
                if (length(cand)) fc <- dplyr::rename(fc, .index = !!rlang::sym(cand[1]))
        }
        lo_cand <- intersect(c(".conf_lo","conf_lo",".conf_low","conf_low"), names(fc))
        hi_cand <- intersect(c(".conf_hi","conf_hi",".conf_high","conf_high"), names(fc))
        if (length(lo_cand)) fc <- dplyr::rename(fc, .conf_lo = !!rlang::sym(lo_cand[1]))
        if (length(hi_cand)) fc <- dplyr::rename(fc, .conf_hi = !!rlang::sym(hi_cand[1]))
        fc
}

make_base <- function(df, map) {
        df |>
                transmute(
                        Date,
                        Week,
                        In_person = .data[[map$in_person]],
                        Online    = .data[[map$online]],
                        Total     = .data[[map$total]]
                )
}

monthly_mean <- function(df) {
        df |>
                group_by(Date = floor_date(Date, "month")) |>
                summarise(attendance = round(mean(.data$val, na.rm = TRUE), 2), .groups = "drop")
}

last_week_triplet <- function(base_df) {
        lw <- tail(base_df, 1)
        tibble(Total = lw$Total, In_person = lw$In_person, Online = lw$Online)
}

month_to_date_triplet <- function(base_df) {
        base_df |>
                mutate(Month = floor_date(Date, "month")) |>
                group_by(Month) |>
                summarise(
                        In_person = round(mean(In_person, na.rm = TRUE), 2),
                        Online    = round(mean(Online,    na.rm = TRUE), 2),
                        Total     = round(mean(Total,     na.rm = TRUE), 2),
                        .groups = "drop"
                ) |>
                slice_tail(n = 1)
}

same_month_last_year_triplet <- function(base_df) {
        by_m <- base_df |>
                mutate(Month = floor_date(Date, "month")) |>
                group_by(Month) |>
                summarise(
                        In_person = round(mean(In_person, na.rm = TRUE), 2),
                        Online    = round(mean(Online,    na.rm = TRUE), 2),
                        Total     = round(mean(Total,     na.rm = TRUE), 2),
                        .groups = "drop"
                )
        if (nrow(by_m) >= 13) {
                by_m |> slice_tail(n = 13) |> slice_head(n = 1)
        } else {
                tibble(Month = as.Date(NA), In_person = NA_real_, Online = NA_real_, Total = NA_real_)
        }
}

yoy_delta <- function(curr, prev) {
        tibble(
                Total     = round(curr$Total     - prev$Total,     1),
                In_person = round(curr$In_person - prev$In_person, 1),
                Online    = round(curr$Online    - prev$Online,    1)
        ) |>
                mutate(
                        Total_percent     = Total     / prev$Total,
                        In_person_percent = In_person / prev$In_person,
                        Online_percent    = Online    / prev$Online
                )
}

ytd_averages <- function(df_base) {
        by_week <- df_base |>
                mutate(Year = year(Date), MonthLbl = month(Date, label = TRUE))
        end_week <- tail(by_week$Week, 1)
        curr_year <- tail(by_week$Year, 1)
        prev_year <- curr_year - 1
        curr_month_lbl <- tail(by_week$MonthLbl, 1)
        
        past_year <- subset(by_week, Year == prev_year & Week <= end_week)
        curr_yr   <- subset(by_week, Year == curr_year)
        
        weekly_ave_past <- summarise(
                past_year,
                Total     = round(mean(Total,     na.rm = TRUE), 1),
                In_person = round(mean(In_person, na.rm = TRUE), 1),
                Online    = round(mean(Online,    na.rm = TRUE), 1)
        )
        weekly_ave_curr <- summarise(
                curr_yr,
                Total     = round(mean(Total,     na.rm = TRUE), 2),
                In_person = round(mean(In_person, na.rm = TRUE), 2),
                Online    = round(mean(Online,    na.rm = TRUE), 2)
        )
        
        list(
                end_week = end_week,
                curr_year = curr_year,
                prev_year = prev_year,
                curr_month_lbl = curr_month_lbl,
                weekly_ave_past = weekly_ave_past,
                weekly_ave_curr = weekly_ave_curr
        )
}

make_main_table <- function(lastweek, mtd, prev, curr_flags) {
        mat <- matrix(c(
                lastweek$Total,     lastweek$In_person,     lastweek$Online,
                mtd$Total,          mtd$In_person,          mtd$Online,
                prev$Total,         prev$In_person,         prev$Online,
                NA,                 NA,                     NA,
                NA,                 NA,                     NA
        ), ncol = 5, byrow = FALSE)
        
        deltas <- yoy_delta(mtd, prev)
        mat[,4] <- c(deltas$Total, deltas$In_person, deltas$Online)
        mat[,5] <- c(
                label_percent(0.1)(deltas$Total_percent),
                label_percent(0.1)(deltas$In_person_percent),
                label_percent(0.1)(deltas$Online_percent)
        )
        
        colnames(mat) <- c(
                "Last week",
                paste(curr_flags$curr_month_lbl, curr_flags$curr_year),
                paste(curr_flags$curr_month_lbl, curr_flags$prev_year),
                "Change", "Percent change"
        )
        rownames(mat) <- c("Combined", "In person", "Online")
        mat
}

make_ytd_table <- function(curr_flags) {
        chg <- tibble(
                Total     = curr_flags$weekly_ave_curr$Total     - curr_flags$weekly_ave_past$Total,
                In_person = curr_flags$weekly_ave_curr$In_person - curr_flags$weekly_ave_past$In_person,
                Online    = curr_flags$weekly_ave_curr$Online    - curr_flags$weekly_ave_past$Online
        ) |>
                mutate(
                        Total_percent     = Total     / curr_flags$weekly_ave_past$Total,
                        In_person_percent = In_person / curr_flags$weekly_ave_past$In_person,
                        Online_percent    = Online    / curr_flags$weekly_ave_past$Online
                )
        mat <- matrix(c(
                curr_flags$weekly_ave_curr$Total,
                curr_flags$weekly_ave_curr$In_person,
                curr_flags$weekly_ave_curr$Online,
                curr_flags$weekly_ave_past$Total,
                curr_flags$weekly_ave_past$In_person,
                curr_flags$weekly_ave_past$Online,
                round(chg$Total, 1),
                round(chg$In_person, 1),
                round(chg$Online,  1),
                label_percent(0.1)(chg$Total_percent),
                label_percent(0.1)(chg$In_person_percent),
                label_percent(0.1)(chg$Online_percent)
        ), ncol = 4, byrow = FALSE)
        colnames(mat) <- c(paste(curr_flags$curr_year), paste(curr_flags$prev_year), "Change", "Percent change")
        rownames(mat) <- c("Combined", "In person", "Online")
        mat
}

make_monthly_datasets <- function(base_df) {
        list(
                in_person = base_df |> transmute(Date, val = In_person) |> monthly_mean(),
                online    = base_df |> filter(Date >= as.Date("2017-12-01")) |> transmute(Date, val = Online) |> monthly_mean(),
                total     = base_df |> transmute(Date, val = Total) |> monthly_mean()
        )
}

# ===== SDA holidays / regressors =====

# Prophet-style weekly holidays (Saturday services mapped to WeekStart Monday)
make_holiday_df_weekly <- function(date_range) {
        yrs <- seq(year(min(date_range, na.rm = TRUE)) - 1,
                   year(max(date_range, na.rm = TRUE)) + 1)
        
        wk_monday <- function(d) floor_date(as.Date(d), "week", week_start = 1)
        
        # Easter Saturday
        easter_sun <- as.Date(timeDate::Easter(yrs))
        easter_sat <- easter_sun - 1L
        
        # Christmas service Saturday (or Dec 25 if Saturday)
        dec25 <- as.Date(paste0(yrs, "-12-25"))
        wd    <- wday(dec25, week_start = 1)         # Mon=1 ... Sat=6 Sun=7
        back2sat <- (wd - 6L) %% 7L
        christmas_service <- dec25 - back2sat
        
        # Graduation Saturday (Saturday before Memorial Day Monday)
        memorial_mon <- as.Date(sapply(yrs, function(y) {
                may <- seq.Date(as.Date(paste0(y,"-05-01")), as.Date(paste0(y,"-05-31")), by="day")
                tail(may[weekdays(may) == "Monday"], 1)
        }))
        grad_sat <- memorial_mon - 2L
        
        make_h <- function(name, dates) tibble(
                holiday = name,
                ds = unique(wk_monday(dates)),
                lower_window = 0, upper_window = 0
        )
        
        bind_rows(
                make_h("Easter_Saturday", easter_sat),
                make_h("Christmas_Service", christmas_service),
                make_h("Graduation_Saturday", grad_sat),
                make_h("MemorialDay_Week", memorial_mon)   # optional small effect
        ) |>
                distinct(holiday, ds, .keep_all = TRUE)
}

# Regressor dummies for ARIMA-xreg (0/1 flags) aligned to weekly Mondays
sda_regressors_for_dates <- function(date_vec) {
        rng <- c(min(date_vec, na.rm = TRUE) - years(1),
                 max(date_vec, na.rm = TRUE) + years(1))
        h <- make_holiday_df_weekly(rng)
        
        wk <- tibble(date = as.Date(date_vec))
        is_easter  <- wk$date %in% h$ds[h$holiday == "Easter_Saturday"]
        is_xmas    <- wk$date %in% h$ds[h$holiday == "Christmas_Service"]
        is_grad    <- wk$date %in% h$ds[h$holiday == "Graduation_Saturday"]
        is_memwk   <- wk$date %in% h$ds[h$holiday == "MemorialDay_Week"]
        
        wk |>
                mutate(
                        is_easter_sat = as.integer(is_easter),
                        is_christmas_service = as.integer(is_xmas),
                        is_graduation_sat = as.integer(is_grad),
                        is_memorial_week  = as.integer(is_memwk)
                )
}

# ----- Weekly regularization & imputation -----
to_weekly_regular <- function(df, reopen_date) {
        wk <- df %>%
                filter(Date >= reopen_date) %>%
                transmute(WeekStart = floor_date(Date, "week", week_start = 1),
                          In_person, Online, Total) %>%
                group_by(WeekStart) %>%
                summarise(
                        In_person = mean(In_person, na.rm = TRUE),
                        Online    = mean(Online,    na.rm = TRUE),
                        Total     = mean(Total,     na.rm = TRUE),
                        .groups = "drop"
                ) %>%
                arrange(WeekStart)
        
        full_weeks <- tibble(WeekStart = seq(min(wk$WeekStart), max(wk$WeekStart), by = "1 week"))
        wk_full <- full_weeks %>%
                left_join(wk, by = "WeekStart") %>%
                mutate(was_missing = if_else(is.na(Total) & is.na(In_person) & is.na(Online), 1L, 0L))
        
        wk_full %>%
                mutate(
                        In_person = imputeTS::na_interpolation(In_person, option = "linear"),
                        Online    = imputeTS::na_interpolation(Online,    option = "linear"),
                        Total     = imputeTS::na_interpolation(Total,     option = "linear")
                )
}

# ----- Build modeling set for a chosen series (+ regressors) -----
build_series_tbl <- function(wk_regular_df, which_series = c("total","in_person","online")) {
        which_series <- match.arg(which_series)
        col <- switch(which_series,
                      in_person = "In_person",
                      online    = "Online",
                      total     = "Total")
        base <- wk_regular_df %>% transmute(date = WeekStart, value = .data[[col]])
        regs <- sda_regressors_for_dates(base$date) %>% select(-date)
        bind_cols(base, regs)
}

# Future exogenous frame for horizon weeks
make_future_xreg <- function(series_tbl, horizon_weeks) {
        future_dates <- timetk::future_frame(series_tbl, .date_var = date,
                                             .length_out = horizon_weeks, .bind_data = FALSE)
        future_regs  <- sda_regressors_for_dates(future_dates$date) %>% select(-date)
        bind_cols(future_dates, future_regs)
}

# ---- NEW: Learn event uplifts from history (additive deltas) ----
compute_event_uplifts <- function(series_tbl, lookback_years = 3) {
        series_tbl <- series_tbl %>%
                mutate(Year = lubridate::year(date),
                       Month = lubridate::month(date))
        
        # Baselines for delta/ratio learning (same as before)
        dec_base <- series_tbl %>%
                filter(Month == 12) %>%
                group_by(Year) %>%
                summarise(base = median(value, na.rm = TRUE), .groups = "drop")
        
        may_base <- series_tbl %>%
                filter(Month == 5) %>%
                group_by(Year) %>%
                summarise(base = median(value, na.rm = TRUE), .groups = "drop")
        
        marapr_base <- series_tbl %>%
                filter(Month %in% c(3, 4)) %>%
                group_by(Year) %>%
                summarise(base = median(value, na.rm = TRUE), .groups = "drop")
        
        # helper to learn additive/multiplicative vs baseline
        learn_event <- function(flag_col, base_tbl) {
                ev <- series_tbl %>% filter(.data[[flag_col]] == 1)
                if (nrow(ev) == 0) {
                        return(list(add = 0, mult = 0, max = NA_real_, med3 = NA_real_))
                }
                ev_with_base <- ev %>%
                        left_join(base_tbl, by = "Year") %>%
                        mutate(
                                delta = value - base,
                                ratio = ifelse(is.finite(base) & base > 0, value / base - 1, NA_real_)
                        )
                
                # last-N-years median for this event
                yrs <- sort(unique(ev$Year), decreasing = TRUE)
                yrs_sel <- head(yrs, lookback_years)
                med3 <- suppressWarnings(stats::median(ev$value[ev$Year %in% yrs_sel], na.rm = TRUE))
                
                list(
                        add  = suppressWarnings(stats::median(ev_with_base$delta, na.rm = TRUE) %||% 0),
                        mult = suppressWarnings(stats::median(ev_with_base$ratio, na.rm = TRUE) %||% 0),
                        max  = suppressWarnings(max(ev$value, na.rm = TRUE)),
                        med3 = if (is.finite(med3)) med3 else NA_real_
                )
        }
        
        easter  <- learn_event("is_easter_sat",        marapr_base)
        xmas    <- learn_event("is_christmas_service", dec_base)
        grad    <- learn_event("is_graduation_sat",    may_base)
        
        # safety
        for (nm in c("add","mult")) {
                if (!is.finite(easter[[nm]])) easter[[nm]] <- 0
                if (!is.finite(xmas[[nm]]))   xmas[[nm]]   <- 0
                if (!is.finite(grad[[nm]]))   grad[[nm]]   <- 0
        }
        
        list(easter = easter, xmas = xmas, grad = grad)
}

# Apply uplifts to forecast rows that are event weeks
apply_event_uplifts <- function(fc_all, future_tbl, uplifts,
                                grad_add_shrink = 0.60,
                                grad_mult_shrink = 0.25,
                                min_mult_easter = 0.15,
                                min_mult_xmas   = 0.15,
                                min_mult_grad   = 0.05,
                                band_lo = 0.05,
                                band_hi = 0.05) {
        
        # Ensure CI columns exist
        if (!(".conf_lo" %in% names(fc_all))) fc_all$.conf_lo <- NA_real_
        if (!(".conf_hi" %in% names(fc_all))) fc_all$.conf_hi <- NA_real_
        
        # Build per-row multipliers and additive deltas keyed by .index
        build_adj <- future_tbl %>%
                transmute(
                        .index = date,
                        # Multipliers (1 + ratio), with floors
                        mult_easter = 1 + max(uplifts$easter$mult, min_mult_easter),
                        mult_xmas   = 1 + max(uplifts$xmas$mult,   min_mult_xmas),
                        mult_grad   = 1 + max(uplifts$grad$mult * grad_mult_shrink, min_mult_grad),
                        
                        # Additive deltas
                        add_easter  = uplifts$easter$add,
                        add_xmas    = uplifts$xmas$add,
                        add_grad    = uplifts$grad$add * grad_add_shrink,
                        
                        # Flags
                        f_easter = is_easter_sat,
                        f_xmas   = is_christmas_service,
                        f_grad   = is_graduation_sat
                ) %>%
                mutate(
                        # Combine effects only when flag is on
                        mult_total = (ifelse(f_easter == 1, mult_easter, 1)) *
                                (ifelse(f_xmas   == 1, mult_xmas,   1)) *
                                (ifelse(f_grad   == 1, mult_grad,   1)),
                        add_total  = ifelse(f_easter == 1, add_easter, 0) +
                                ifelse(f_xmas   == 1, add_xmas,   0) +
                                ifelse(f_grad   == 1, add_grad,   0)
                ) %>%
                select(.index, mult_total, add_total, f_easter, f_xmas, f_grad)
        
        out <- fc_all %>%
                left_join(build_adj, by = ".index") %>%
                mutate(
                        mult_total = ifelse(.key == "prediction", coalesce(mult_total, 1), 1),
                        add_total  = ifelse(.key == "prediction", coalesce(add_total,  0), 0),
                        
                        # Apply multiplicative then additive
                        .value   = (.value   * mult_total) + add_total,
                        .conf_lo = (.conf_lo * mult_total) + add_total,
                        .conf_hi = (.conf_hi * mult_total) + add_total
                )
        
        # ---- Median-of-last-3-years centering band per event (± band)
        # helper to clamp against an event's median band if that event is active
        clamp_to_band <- function(val, lo_band, hi_band, flag) {
                ifelse(flag == 1, pmin(pmax(val, lo_band), hi_band), val)
        }
        
        # Precompute bands (only if medians exist)
        e_med <- uplifts$easter$med3
        x_med <- uplifts$xmas$med3
        g_med <- uplifts$grad$med3
        
        if (is.finite(e_med) || is.finite(x_med) || is.finite(g_med)) {
                out <- out %>%
                        mutate(
                                # compute per-row bands (NA means no clamp for that event)
                                e_lo = if (is.finite(e_med)) e_med * (1 - band_lo) else NA_real_,
                                e_hi = if (is.finite(e_med)) e_med * (1 + band_hi) else NA_real_,
                                x_lo = if (is.finite(x_med)) x_med * (1 - band_lo) else NA_real_,
                                x_hi = if (is.finite(x_med)) x_med * (1 + band_hi) else NA_real_,
                                g_lo = if (is.finite(g_med)) g_med * (1 - band_lo) else NA_real_,
                                g_hi = if (is.finite(g_med)) g_med * (1 + band_hi) else NA_real_,
                                
                                # Only clamp predictions
                                .value   = ifelse(.key == "prediction",
                                                  clamp_to_band(.value,   coalesce(e_lo, -Inf), coalesce(e_hi,  Inf), coalesce(f_easter, 0)),
                                                  .value),
                                .value   = ifelse(.key == "prediction",
                                                  clamp_to_band(.value,   coalesce(x_lo, -Inf), coalesce(x_hi,  Inf), coalesce(f_xmas,   0)),
                                                  .value),
                                .value   = ifelse(.key == "prediction",
                                                  clamp_to_band(.value,   coalesce(g_lo, -Inf), coalesce(g_hi,  Inf), coalesce(f_grad,   0)),
                                                  .value),
                                
                                .conf_hi = ifelse(.key == "prediction",
                                                  pmax(.conf_hi, .value), .conf_hi),
                                .conf_lo = ifelse(.key == "prediction",
                                                  pmin(.conf_lo, .value), .conf_lo)
                        ) %>%
                        select(-e_lo, -e_hi, -x_lo, -x_hi, -g_lo, -g_hi)
        }
        
        # Tidy
        out %>% select(-mult_total, -add_total, -f_easter, -f_xmas, -f_grad)
}

# ----- Fit models & performance-weighted ensemble -----
fit_ensemble_weighted <- function(series_tbl, holidays_df, horizon_weeks = 13, conf = 0.80) {
        set.seed(123)
        
        split <- time_series_split(series_tbl, assess = horizon_weeks, cumulative = TRUE)
        
        # Prophet with stronger holiday prior & multiplicative mode
        m_prophet <- prophet_reg(
                seasonality_yearly = TRUE,
                seasonality_weekly = TRUE,
                changepoint_num = 25
        ) %>%
                set_engine("prophet",
                           holidays = holidays_df,
                           holidays_prior_scale = 35,
                           seasonality_mode = "multiplicative",
                           changepoint_prior_scale = 0.1) %>%
                fit(value ~ date, data = training(split))
        
        # Baseline ARIMA
        m_arima <- arima_reg() %>%
                set_engine("auto_arima") %>%
                fit(value ~ date, data = training(split))
        
        # Regression ARIMA with SDA holiday dummies
        m_arima_x <- arima_reg() %>%
                set_engine("auto_arima") %>%
                fit(value ~ date + is_easter_sat + is_christmas_service + is_graduation_sat + is_memorial_week,
                    data = training(split))
        
        # ETS
        m_ets <- exp_smoothing() %>%
                set_engine("ets") %>%
                fit(value ~ date, data = training(split))
        
        models_tbl <- modeltime_table(m_prophet, m_arima, m_arima_x, m_ets)
        
        cal <- models_tbl %>% modeltime_calibrate(new_data = testing(split))
        acc <- cal %>% modeltime_accuracy() %>% normalize_metric_names()
        
        # Keep finite RMSE models
        acc_keep <- acc %>% dplyr::filter(is.finite(rmse))
        keep_ids <- acc_keep$model_id
        
        if (length(keep_ids) == 0) {
                best_id <- acc %>% dplyr::arrange(rmse) %>% dplyr::slice(1) %>% dplyr::pull(model_id)
                if (length(best_id) == 0 || is.na(best_id)) best_id <- models_tbl$.model_id[[1]]
                ens_tbl   <- models_tbl %>% dplyr::filter(.model_id == best_id)
                refit_ens <- ens_tbl %>% modeltime_refit(data = series_tbl)
                acc$weight <- ifelse(acc$model_id == best_id, 1, NA_real_)
                return(list(split = split, accuracy = acc, refit = refit_ens, conf = conf))
        }
        
        # Align calibration to kept ids / order
        cal_keep <- cal %>%
                dplyr::filter(.model_id %in% keep_ids) %>%
                dplyr::arrange(match(.model_id, keep_ids))
        
        # Inverse-RMSE weights
        inv_rmse <- 1 / acc_keep$rmse
        inv_rmse[!is.finite(inv_rmse)] <- NA_real_
        if (any(is.na(inv_rmse))) inv_rmse[is.na(inv_rmse)] <- min(inv_rmse, na.rm = TRUE) * 0.5
        w <- inv_rmse / sum(inv_rmse)
        
        # Weight floor: favor holiday-aware models
        desc <- tolower(acc_keep$model_desc)
        is_prophet <- grepl("prophet", desc)
        is_arimax  <- grepl("arima", desc) & grepl("xreg", desc)
        
        w_min <- numeric(length(w))
        if (any(is_prophet)) w_min[is_prophet] <- 0.35
        if (any(is_arimax))  w_min[is_arimax]  <- 0.30
        
        total_floor <- sum(w_min)
        if (total_floor > 0 && total_floor < 0.95) {
                w_rescaled <- (1 - total_floor) * (w / sum(w))
                w <- w_rescaled + w_min
                w <- w / sum(w)
        }
        
        if (length(w) == 1 || !ok_ens) {
                solo_id  <- keep_ids[[1]]
                ens_tbl  <- models_tbl %>% dplyr::filter(.model_id == solo_id)
                refit_ens <- ens_tbl %>% modeltime_refit(data = series_tbl)
                acc$weight <- ifelse(acc$model_id == solo_id, 1, NA_real_)
        } else {
                ens_obj <- modeltime.ensemble::ensemble_weighted(cal_keep, w)
                ens_tbl <- modeltime_table(ens_obj)
                refit_ens <- ens_tbl %>% modeltime_refit(data = series_tbl)
                acc <- acc %>%
                        dplyr::left_join(tibble(model_id = keep_ids, weight = round(w, 4)), by = "model_id")
        }
        
        list(split = split, accuracy = acc, refit = refit_ens, conf = conf)
}

# ----- Forecast helper (uses future xregs + applies uplifts) -----
make_future_xreg <- function(series_tbl, horizon_weeks) {
        future_dates <- timetk::future_frame(series_tbl, .date_var = date,
                                             .length_out = horizon_weeks, .bind_data = FALSE)
        future_regs  <- sda_regressors_for_dates(future_dates$date) %>% select(-date)
        bind_cols(future_dates, future_regs)
}

# Replace your current apply_event_uplifts() with this version
# Replace your apply_event_uplifts() with this version
apply_event_uplifts <- function(fc_all, future_tbl, uplifts,
                                grad_add_shrink = 0.60,
                                grad_mult_shrink = 0.25,
                                grad_cap_buffer = 0.02,
                                min_mult_easter = 0.15,
                                min_mult_xmas   = 0.15,
                                min_mult_grad   = 0.05) {
        
        # Ensure CI columns exist so we can safely add to them
        if (!(".conf_lo" %in% names(fc_all))) fc_all$.conf_lo <- NA_real_
        if (!(".conf_hi" %in% names(fc_all))) fc_all$.conf_hi <- NA_real_
        
        # Build per-row multipliers and additive deltas keyed by .index
        build_adj <- future_tbl %>%
                transmute(
                        .index = date,
                        # Multipliers (1 + ratio)
                        mult_easter = 1 + max(uplifts$easter$mult, min_mult_easter),
                        mult_xmas   = 1 + max(uplifts$xmas$mult,   min_mult_xmas),
                        mult_grad   = 1 + max(uplifts$grad$mult * grad_mult_shrink, min_mult_grad),
                        
                        # Additive deltas
                        add_easter  = uplifts$easter$add,
                        add_xmas    = uplifts$xmas$add,
                        add_grad    = uplifts$grad$add * grad_add_shrink,
                        
                        # Flags
                        f_easter = is_easter_sat,
                        f_xmas   = is_christmas_service,
                        f_grad   = is_graduation_sat
                ) %>%
                mutate(
                        # Combine only when the flag is on
                        mult_total = (ifelse(f_easter == 1, mult_easter, 1)) *
                                (ifelse(f_xmas   == 1, mult_xmas,   1)) *
                                (ifelse(f_grad   == 1, mult_grad,   1)),
                        add_total  = ifelse(f_easter == 1, add_easter, 0) +
                                ifelse(f_xmas   == 1, add_xmas,   0) +
                                ifelse(f_grad   == 1, add_grad,   0)
                ) %>%
                select(.index, mult_total, add_total, f_grad)
        
        # Join and adjust ONLY the prediction rows
        out <- fc_all %>%
                left_join(build_adj, by = ".index") %>%
                mutate(
                        mult_total = ifelse(.key == "prediction", coalesce(mult_total, 1), 1),
                        add_total  = ifelse(.key == "prediction", coalesce(add_total,  0), 0),
                        
                        # Apply multiplicative then additive
                        .value   = (.value   * mult_total) + add_total,
                        .conf_lo = (.conf_lo * mult_total) + add_total,
                        .conf_hi = (.conf_hi * mult_total) + add_total
                )
        
        # Cap Graduation weeks to historical max (+ buffer)
        if (is.finite(uplifts$grad$max) && uplifts$grad$max > 0) {
                cap_val <- uplifts$grad$max * (1 + grad_cap_buffer)
                out <- out %>%
                        mutate(
                                .value   = ifelse(.key == "prediction" & coalesce(f_grad, 0) == 1,
                                                  pmin(.value, cap_val), .value),
                                .conf_hi = ifelse(.key == "prediction" & coalesce(f_grad, 0) == 1,
                                                  pmin(.conf_hi, cap_val), .conf_hi),
                                # keep CI lower sensible
                                .conf_lo = pmin(.conf_lo, .value)
                        )
        }
        
        # Tidy
        out %>% select(-mult_total, -add_total, -f_grad)
}

# Replace your make_forecast() with this version
make_forecast <- function(refit_ens, series_tbl, horizon_weeks = 13, conf = 0.80, uplifts = NULL) {
        future_tbl <- make_future_xreg(series_tbl, horizon_weeks)
        
        fc <- refit_ens %>%
                modeltime_forecast(
                        new_data    = future_tbl,      # needed for ARIMA-xreg
                        actual_data = series_tbl,
                        conf_interval = conf
                ) %>%
                normalize_forecast_cols()
        
        # Post-adjust: apply learned uplifts (acts only on .key == "prediction")
        if (!is.null(uplifts)) {
                fc <- apply_event_uplifts(fc_all = fc, future_tbl = future_tbl, uplifts = uplifts)
        }
        
        fc
}

## ------------------------------
## 4) Attendance module (UI)
## ------------------------------
attendanceTabUI <- function(id, tab_title) {
        ns <- NS(id)
        tabPanel(
                tab_title,
                sidebarLayout(
                        sidebarPanel(
                                selectInput(ns("dataset"), label = h3("Attendance data set"),
                                            choices = list("Total" = "total", "In Person" = "in_person", "Online" = "online"),
                                            selected = "total"),
                                p("Choose in-person, online, or total attendance."),
                                selectInput(ns("month"), label = h3("Month"),
                                            choices = list("All"="all","January"="jan","February"="feb","March"="mar","April"="apr",
                                                           "May"="may","June"="jun","July"="jul","August"="aug","September"="sep",
                                                           "October"="oct","November"="nov","December"="dec"),
                                            selected = "all"),
                                p("Filter the seasonal plot by month")
                        ),
                        mainPanel(
                                h3("By the Numbers"),
                                h4("Current Attendance per week"),
                                htmlOutput(ns("main_table")),
                                h4("Year-to-date attendance per week"),
                                htmlOutput(ns("ytd_table")),
                                h3("Attendance Over Time"),
                                plotlyOutput(ns("seasonal")),
                                h3("Seasonal attendance patterns"),
                                plotlyOutput(ns("spaghetti"))
                        )
                )
        )
}

## --------------------------------
## 5) Attendance module (Server)
## --------------------------------
attendanceTabServer <- function(id, base_df, monthly_sets, curr_flags) {
        moduleServer(id, function(input, output, session) {
                
                month_key <- c(all = NA, jan = 1, feb = 2, mar = 3, apr = 4, may = 5, jun = 6,
                               jul = 7, aug = 8, sep = 9, oct = 10, nov = 11, dec = 12)
                sel_months <- reactive({
                        sel <- month_key[[input$month]]
                        if (is.na(sel)) 1:12 else sel
                })
                
                # Tables
                lw   <- last_week_triplet(base_df)
                mtd  <- month_to_date_triplet(base_df)
                prev <- same_month_last_year_triplet(base_df)
                main_tbl <- make_main_table(lw, mtd, prev, curr_flags)
                ytd_tbl  <- make_ytd_table(curr_flags)
                
                output$main_table <- renderUI({
                        tbl <- kbl(main_tbl, row.names = TRUE) |>
                                kable_styling(bootstrap_options = c("striped"), full_width = FALSE) |>
                                add_header_above(c(" " = 1, " " = 1, "Weekly Average" = 2, "Year-over-year" = 2)) |>
                                column_spec(1, bold = TRUE)
                        HTML(as.character(tbl))
                })
                
                output$ytd_table  <- renderUI({
                        tbl <- kbl(ytd_tbl, row.names = TRUE) |>
                                kable_styling(bootstrap_options = c("striped"), full_width = FALSE) |>
                                add_header_above(c(" " = 1, "Year-to-date weekly average" = 2, " " = 1, " " = 1)) |>
                                column_spec(1, bold = TRUE)
                        HTML(as.character(tbl))
                })
                
                ds_reactive <- reactive({
                        switch(input$dataset,
                               in_person = monthly_sets$in_person,
                               online    = monthly_sets$online,
                               total     = monthly_sets$total)
                })
                
                output$seasonal <- renderPlotly({
                        d <- ds_reactive() |> filter(month(Date) %in% sel_months())
                        gp <- ggplot(d, aes(Date, attendance)) +
                                theme_classic() +
                                geom_point() +
                                geom_line() +
                                geom_smooth(method = "loess", formula = "y~x", col = "red") +
                                labs(title = "Weekly average attendance by month",
                                     x = "Date", y = "Average attendance")
                        ggplotly(gp)
                })
                
                output$spaghetti <- renderPlotly({
                        d <- ds_reactive()
                        s <- d |>
                                mutate(Year = factor(year(Date)), Date = update(Date, year = 1)) |>
                                ggplot(aes(Date, attendance, colour = Year)) +
                                scale_x_date(date_breaks = "1 month", date_labels = "%b") +
                                geom_line(aes(group = Year), colour = "black", alpha = 0.1) +
                                geom_line(data = function(x) filter(x, Year == curr_flags$prev_year), lwd = 0.5) +
                                geom_line(data = function(x) filter(x, Year == curr_flags$curr_year), lwd = 1) +
                                theme_bw() +
                                labs(y = "Average attendance per week", x = "Month")
                        ggplotly(s)
                })
        })
}

## ------------------------------
## 6) Forecast module (UI)
## ------------------------------
forecastTabUI <- function(id) {
        ns <- NS(id)
        tabPanel(
                "Forecast",
                sidebarLayout(
                        sidebarPanel(
                                selectInput(ns("fc_service"), "Service",
                                            choices = c("Overall" = "overall", "Ascent" = "ascent", "Sanctuary" = "sanct"),
                                            selected = "overall"),
                                selectInput(ns("fc_dataset"), "Data set",
                                            choices = c("Total" = "total", "In Person" = "in_person", "Online" = "online"),
                                            selected = "total"),
                                sliderInput(ns("fc_horizon"), "Forecast horizon (weeks)", min = 8, max = 52, value = 26, step = 1),
                                helpText("Performance-weighted ensemble: Prophet + ARIMA (+xregs) + ETS with SDA holiday effects and 80% intervals + event uplifts.")
                        ),
                        mainPanel(
                                h3("Weekly Attendance Forecast (2 to 12 months)"),
                                plotlyOutput(ns("fc_plot")),
                                br(),
                                h4("Backtest accuracy (last horizon)"),
                                tableOutput(ns("fc_accuracy"))
                        )
                )
        )
}

## ------------------------------
## 7) Forecast module (Server)
## ------------------------------
forecastTabServer <- function(id, Weekly_data, svc_map) {
        moduleServer(id, function(input, output, session) {
                
                get_base_df <- reactive({
                        switch(input$fc_service,
                               overall = make_base(Weekly_data, svc_map$overall),
                               ascent  = make_base(Weekly_data, svc_map$ascent),
                               sanct   = make_base(Weekly_data, svc_map$sanct))
                })
                
                wk_regular <- reactive({
                        to_weekly_regular(get_base_df(), as.Date("2021-04-03"))
                })
                
                series_tbl <- reactive({
                        build_series_tbl(wk_regular(), input$fc_dataset)
                })
                
                holidays_df <- reactive({
                        make_holiday_df_weekly(series_tbl()$date)
                })
                
                # NEW: learn uplifts from history for the currently selected service/dataset
                event_uplifts <- reactive({
                        compute_event_uplifts(series_tbl())
                })
                
                .model_cache <- reactiveVal(new.env(parent = emptyenv()))
                
                get_fit <- reactive({
                        key <- paste(input$fc_service, input$fc_dataset, sep = "_")
                        cache <- .model_cache()
                        if (!exists(key, envir = cache)) {
                                fit <- fit_ensemble_weighted(
                                        series_tbl = series_tbl(),
                                        holidays_df = holidays_df(),
                                        horizon_weeks = input$fc_horizon,
                                        conf = 0.80
                                )
                                assign(key, fit, envir = cache)
                        }
                        get(key, envir = cache)
                })
                
                output$fc_accuracy <- renderTable({
                        acc <- get_fit()$accuracy |> normalize_metric_names()
                        acc %>%
                                dplyr::select(model_desc = dplyr::any_of(c("model_desc", ".model_desc")),
                                              rmse, mae, mape, rsq, weight) %>%
                                dplyr::mutate(dplyr::across(where(is.numeric), ~ round(.x, 3)))
                })
                
                output$fc_plot <- renderPlotly({
                        fit <- get_fit()
                        fc <- make_forecast(
                                refit_ens = fit$refit,
                                series_tbl = series_tbl(),
                                horizon_weeks = input$fc_horizon,
                                conf = fit$conf,
                                uplifts = event_uplifts()
                        )
                        
                        act  <- dplyr::filter(fc, .key == "actual")
                        pred <- dplyr::filter(fc, .key == "prediction")
                        
                        have_ci_cols <- all(c(".conf_lo", ".conf_hi") %in% names(pred))
                        need_ci_fallback <- !have_ci_cols || !any(is.finite(pred$.conf_lo) & is.finite(pred$.conf_hi))
                        if (need_ci_fallback && nrow(pred)) {
                                acc <- fit$accuracy; names(acc) <- gsub("^\\.", "", names(acc))
                                acc_ok <- acc %>% dplyr::filter(is.finite(rmse))
                                if (nrow(acc_ok) > 0) {
                                        if ("weight" %in% names(acc_ok) && any(is.finite(acc_ok$weight))) {
                                                wts <- acc_ok$weight; wts[!is.finite(wts)] <- 0
                                                if (sum(wts) == 0) wts <- rep(1/nrow(acc_ok), nrow(acc_ok))
                                                rmse_eff <- sum(wts * acc_ok$rmse)
                                        } else {
                                                rmse_eff <- mean(acc_ok$rmse)
                                        }
                                        z80 <- 1.281552
                                        pred$.conf_lo <- pred$.value - z80 * rmse_eff
                                        pred$.conf_hi <- pred$.value + z80 * rmse_eff
                                }
                        }
                        
                        p <- plotly::plot_ly()
                        if (nrow(pred)) {
                                # CI ribbon first (if present)
                                if (all(c(".conf_lo", ".conf_hi") %in% names(pred)) &&
                                    any(is.finite(pred$.conf_lo) & is.finite(pred$.conf_hi))) {
                                        p <- p %>% add_ribbons(
                                                data = pred,
                                                x = ~.index, ymin = ~.conf_lo, ymax = ~.conf_hi,
                                                name = "80% CI", hoverinfo = "skip", opacity = 0.25
                                        )
                                }
                        }
                        if (nrow(act))  p <- p %>% add_lines(data = act,  x = ~.index, y = ~.value, name = "Actuals")
                        if (nrow(pred)) p <- p %>% add_lines(data = pred, x = ~.index, y = ~.value, name = "Forecast")
                        
                        p %>%
                                layout(
                                        title = "Weekly Attendance Forecast (80% confidence interval + event uplifts)",
                                        xaxis = list(title = "Week"),
                                        yaxis = list(title = "Attendance"),
                                        legend = list(orientation = "h", x = 0, y = 1.1)
                                )
                })
        })
}

## --------------------------
## 8) UI
## --------------------------
ui <- fluidPage(
        titlePanel("Kettering SDA Church Attendance"),
        tabsetPanel(
                attendanceTabUI("overall",   "Overall"),
                attendanceTabUI("ascent",    "Ascent"),
                attendanceTabUI("sanctuary", "Sanctuary"),
                forecastTabUI("forecast")
        ),
        hr(),
        h4("Created by: Jim Milks"),
        "Version 6.6", br(),
        format(Sys.Date(), "%d %B %Y"), br(),
        "Code and data available at:",
        a(href = "https://github.com/jrmilks74/KetSDA/tree/main",
          "https://github.com/jrmilks74/KetSDA/tree/main"),
        br(),
        "Data updated every Monday"
)

## --------------------------
## 9) Server
## --------------------------
server <- function(input, output, session) {
        # OVERALL
        overall_base <- make_base(Weekly_data, svc_map$overall)
        overall_flags <- ytd_averages(overall_base)
        overall_monthly <- make_monthly_datasets(overall_base)
        attendanceTabServer("overall", overall_base, overall_monthly, overall_flags)
        
        # ASCENT
        ascent_base <- make_base(Weekly_data, svc_map$ascent)
        ascent_flags <- ytd_averages(ascent_base)
        ascent_monthly <- make_monthly_datasets(ascent_base)
        attendanceTabServer("ascent", ascent_base, ascent_monthly, ascent_flags)
        
        # SANCTUARY
        sanct_base <- make_base(Weekly_data, svc_map$sanct)
        sanct_flags <- ytd_averages(sanct_base)
        sanct_monthly <- make_monthly_datasets(sanct_base)
        attendanceTabServer("sanctuary", sanct_base, sanct_monthly, sanct_flags)
        
        # FORECAST
        forecastTabServer("forecast", Weekly_data, svc_map)
}

shinyApp(ui, server)
